

étape 1.

Vecteur3D:
Les instances x, y, z sont en privés, pas de protected car Particule::affiche() se sert de Vecteur3D::affiche()

étape 2: 

Par recherche de clarté et pour utiliser plainement la compilation séparé, nous avons plusieurs fois dans notre programme decidé de 
séparer les fichier a chaque étape considérée importante de la conception. Ici nous en avons fait une première créant un vecteur3D.cc un Vecteur3D.h
et un fichier test pour verifier le fonctionnement correct des méthodes

étape 3:

Nous avons mis trois constructeurs dans la classe Vecteur3D et avons pu grâce à eux récrire beaucoup plus facilement une grande parties des méthodes :celles créant une nouvelle instance de la classe.
Les surcharges d'opérateurs peuvent être internes ou externes:
On a utilisé de manière générale la surcharge interne pour les opérateurs qui ne créent pas de nouvel objet/variable de (ex. +=, -=), en revanche les autres opérateurs sont placés en dehors
( << l'est par nécessité, les autres par préférence), on remarque que l'on se sert de += et -= pour les definitions de + et - pour optimiser le programme. Certains autres opérateurs comme ^ ou ~ se servent des méthodes prod_scal et unitaire
conceptionnées plus tôt pour éviter le copier-coller.

étape 4:

Particule:
Cette classe se sert de la classe Vecteur3D car une particule n'est pas tout a fait un vecteur, en revanche la position et la vitesse d'une particule le sont. On ajoute donc #include "Vecteur3D.h" pour se servir de cette classe.
Le constructeur se fait donc naturellement, on prend la décision de créer un constructeur prenant uniquement la masse car le constructeur par défaut de vecteur3D initialisant un vecteur nul a été créé précédemment, en revanche on ne pourra pas créer de vecteur avec position centré en l'origine ou vitesse nulle par défaut pour éviter toute confusion (ex. Particule p1(1.5, 2.3, 4.9, 0.1233) pourrait porter à confusion à savoir si il s'agit de la vitesse ou de la position qui est a (1.5, 2.3, 4.9) car elles sont toutes deux de même type.

Anticipation du besoin d'un destructeur car par le futur nous créeront des milliers de particules.

La méthode affiche() est définie et l'opérateur de surcharge << l'est aussi, en externe.

Enceinte:
cette classe a comme attributs une hauteur , une largeur et une profondeur toutes trois initailasables par défaut à 20.0 par son constructeur.
Elle est principalement utilisée dans la classe Système dans laquelle est en attribut.

étape 5:

Systeme: cette classe qui a comme attrbuts une enceinte et un vector de pointeur sur des particules. L'utilisation de vector est ici clairement pour avoir une résolution dynamique des liens lors de de l'appel aux méthodes des instances du tableau.
Nous avons par soucis d'organisation ici encore pris le choix ici de conserver les classes Systeme et Enceinte (qui n'est pas très conséquente) en 2 fichiers: système.cc système.h

exerciceP7: 
Dans ce fichier nous créons deux sous classes de Particule: Neon et Argon avec les constructeur utilisant cleui de Particule
et leur propre Méthode affiche() : similaires sur le fond mais le nom de la sous Classe s'affiche quand nous l'appellons ce qui nous
a bien permis de vérifier que la bonne méthode affiche était appelée ici et pas celle de Particule.
Nous créons aussi la classe SupportADessin et la sous classe de supportADessin: Textviewer qui permettent avec l'utilisation de la méthode 
dessine_sur de la classe Dessinable ( et remise dans toutes les sous classes de Dessinable) de sortir un flot sur un iostream.
Elles ont plusieurs méthodes Dessine() qui peventt prendre chacune l'instance des classes (Argon,Neon,Enceinte,systeme) en paramètre et qui
utilisent leur surcharges respectives de l'opérateur << pour mofifier le flot en argument.
Nous avons pu la tester sur un cout dans le main de ce fichier.

Testsysteme1:
Similairement au fichier exerciceP7 nous testons l'affichage de particule sur un cout à l'aide d'une instance de Text viewer.
Nouvelle sous classe de Particules ici :Helium 

(Question :qu'elles classes sont dessinable et comment incoporer la redefinition de la méthode dans cest classe definie auparavant??)

!!pas oublié de rajouter les destructeur: Toute classe doit en avoir un

ExerciceP11:

Dans l'exercice P11; on a décidé de supprimer toutes les classes de l'exercicep10 pour l'adapter à notre projet: la classe contenu est remplacée par systeme dont on modifié la méthode dessine_sur pour qu'elle dessine d'abord l'enceinte puis ensuite sa collection de particules. On a supprimé la classe machin qui nous semblait ne pas etre utile étant donné qu' elle n'a pas d'équivalent dans notre projet. La classe bloc elle, est remplacée par Enceinte et Qui tourne,Dervish, Moucheron sont respectivement remplacées par Particule,Neon et Argon avec en plus simillairement a Argon et Neon la classe Helium. On a mis le pas de temps comme attribut de la méthode systeme et pour la représentation de chacunes desparticules et leur différentiation on a introduit les méthodes Dessinecube, DessineSphere et DesssinePyramide de VueOpenGl. Pour dessiner l'enceinte on a du modifié les shaders et la méthode PaintGl en ajoutant une composante alpha pour la transparence.



